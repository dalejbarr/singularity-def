type <- "clmm"
## DO NOT EDIT THIS FILE!
## This file is generated by tangling code blocks in power.org.
options(tidyverse.quiet = TRUE)
library("ordinal")
library("tidyverse")

clmm_mod <- readRDS("../reanalysis_NE/clmm_maximal.rds")
suppressPackageStartupMessages(library("lme4"))

thresh2pmass <- function(x) {
  probs <- c(1 / (1 + exp(-x)), 1L)
  res <- c(probs[1], probs[2:(length(probs))] - probs[1:(length(probs) - 1L)])
  names(res) <- seq_along(res)
  res
}

pmids <- function(x) {
  res <- c(0, cumsum(x))[-(length(x) + 1L)] + x / 2
  names(res) <- names(x)
  res
}

eta2resp <- function(eta, thresh) {
  sapply(eta, function(.x) {
    probs <- c(1 / (1 + exp(-(thresh - .x))), 1L)
    min(which(probs > runif(1)))
  })
}

tryFit <- function(tf.formula, tf.data, ...) {
  converged <- TRUE
  w.handler <- function(w) {
    converged <- FALSE
    invokeRestart("muffleWarning")
  }
  arg.list <- c(list(formula=tf.formula, data=tf.data), list(...))
  list(value=withCallingHandlers(tryCatch(
	 do.call(lme4::lmer, arg.list),
	 error=function(e) e),
	 warning=w.handler),
       converged=converged)
}

fit_lmem <- function(.data) {
  form <- trating ~ R * (I1 + I2 + I3) +
    (1 + R:I1 + R:I2 + R:I3 || subj_id) +
    (1 + R:I1 + R:I2 + R:I3 || item_id)

  form2 <- trating ~ R + I1 + I2 + I3 +
    (1 + R:I1 + R:I2 + R:I3 || subj_id) +
    (1 + R:I1 + R:I2 + R:I3 || item_id)

  ## fit the model and print the results
  el1 <- suppressMessages({tryFit(form, .data, REML = FALSE)})
  el2 <- suppressMessages({tryFit(form2, .data, REML = FALSE)})

  fef <- fixef(el1$value)

  mychisq1 <- deviance(el2$value) - deviance(el1$value)
  pval1 <- pchisq(abs(mychisq1), 3, lower.tail = FALSE)

  c(fef, dev1 = deviance(el1$value), dev2 = deviance(el2$value), 
    chisq_RI = mychisq1, p_RI = pval1,
    m1_singular = isSingular(el1$value),
    m2_singular = isSingular(el2$value),
    m1_conv = el1$converged,
    m2_conv = el2$converged)
}

fit_clmm <- function(.data) {
  .data2 <- mutate(.data,
		   trating = factor(trating, levels = 1:7, ordered = TRUE))

  form <- trating ~ R * (I1 + I2 + I3) +
    (1 + R:I1 + R:I2 + R:I3 | subj_id) +
    (1 + R:I1 + R:I2 + R:I3 | item_id)

  form2 <- trating ~ R + I1 + I2 + I3 +
    (1 + R:I1 + R:I2 + R:I3 | subj_id) +
    (1 + R:I1 + R:I2 + R:I3 | item_id)

  ## fit the model and print the results
  el1 <- clmm(form, .data2, Hess = FALSE)
  el2 <- clmm(form2, .data2, Hess = FALSE)

  fef <- el1$beta

  dev1 <- as.numeric(-2 * logLik(el1))
  dev2 <- as.numeric(-2 * logLik(el2))

  mychisq1 <- dev2 - dev1
  pval1 <- pchisq(abs(mychisq1), 3, lower.tail = FALSE)

  c(fef,
    dev1 = dev1,
    dev2 = dev2, 
    chisq_RI = mychisq1, p_RI = pval1,
    thresh = el1$alpha)
}

gen_data <- function(nsubj,
		     thresh,   # threshold values
		     raw_eff,  # raw effect size
		     subj_rfx, # by-subject random effects
		     item_rfx, # by-item random effects
		     stimlists,
		     dropout = c(.05, .1, .1)) {

  if (nsubj %% 8)
    stop("'nsubj' must be multiple of 8 (the number of stimulus lists)")

  nitem <- stimlists %>%
    count(list_id) %>% pull(n) %>% unique()
  stopifnot(length(nitem) == 1L)

  effnames <- c(
    "(Intercept)",
    "R", "I1", "I2", "I3",
    "R:I1", "R:I2", "R:I3")

  ## fixed effects (betas)
  betas <- c((3 * raw_eff) / 4,
	     rep((raw_eff) / 2, 3),
	     rep(raw_eff, 3))
  names(betas) <- effnames[-1]

  ## variance-covariance matrices
  ## covariances set to zero
  subj_mx <- matrix(0, nrow = 8, ncol = 8,
		    dimnames = list(effnames, effnames))
  diag(subj_mx) <- rep(diag(subj_rfx), c(1, 1, 3, 3))

  item_mx <- matrix(0, nrow = 8, ncol = 8,
		    dimnames = list(effnames, effnames))
  diag(item_mx) <- rep(diag(item_rfx), c(1, 1, 3, 3))

  ## generate random effects for subjects
  mus <- rep(0, length(effnames))
  names(mus) <- effnames
  sfx <- MASS::mvrnorm(nsubj, mus, subj_mx) %>%
    as_tibble() %>%
    mutate(subj_id = row_number())

  ifx <- MASS::mvrnorm(nitem, mus, item_mx) %>%
    as_tibble() %>%
    mutate(item_id = row_number())

  subj <- tibble(subj_id = seq_len(nsubj),
		 list_id = rep(1:8, nsubj / 8L))

  trials <- inner_join(subj, stimlists, "list_id") %>%
    inner_join(sfx, "subj_id") %>%
    inner_join(ifx, "item_id", suffix = c(".s", ".i")) %>%
    mutate(R = if_else(repetition == "old", 1/2, -1/2),
	   I1 = if_else(interval == "1 day", 3/4, -1/4),
	   I2 = if_else(interval == "1 week", 3/4, -1/4),
	   I3 = if_else(interval == "1 month", 3/4, -1/4),
	   eta =
	     `(Intercept).s` + `(Intercept).i` +
	     (R.s + R.i + betas["R"]) * R +
	     (I1.s + I1.i + betas["I1"]) * I1 +
	     (I2.s + I2.i + betas["I2"]) * I2 +
	     (I3.s + I3.i + betas["I3"]) * I3 +
	     (`R:I1.s` + `R:I1.i` + betas["R:I1"]) * R * I1 +
	     (`R:I2.s` + `R:I2.i` + betas["R:I2"]) * R * I2 +
	     (`R:I3.s` + `R:I3.i` + betas["R:I3"]) * R * I3,
	   trating = eta2resp(eta, thresh)) %>%
    select(subj_id, list_id, item_id, repetition, interval, eta,
	   trating, R, I1, I2, I3)

  ## now drop participants
  ## nremaining * dropout rate
  ndrop <- ceiling(dropout * nsubj)
  ndrop[2] <- ceiling((nsubj - ndrop[1]) * dropout[2])
  ndrop[3] <- ceiling((nsubj - ndrop[1] - ndrop[2]) * dropout[3])

  all_sphase <- distinct(trials, subj_id, interval)

  remaining <- distinct(trials, subj_id) %>% pull()
  lvls <- trials %>% pull(interval) %>% levels()
  res <- list()
  for (.i in seq_along(ndrop)) {
    dropped <- sample(remaining, ndrop[.i])
    res[[.i]] <- crossing(subj_id = dropped, interval = lvls[(.i + 1L):length(lvls)])
    remaining <- setdiff(remaining, dropped)
  }

  stopifnot((intersect(intersect(distinct(res[[1]], subj_id), distinct(res[[2]], subj_id)),
		       distinct(res[[3]], subj_id)) %>% nrow()) == 0L)

  discard <- bind_rows(res[[1]], res[[2]], res[[3]]) %>%
    mutate(interval = factor(interval, levels = lvls))
  stopifnot(nrow(distinct(discard, subj_id)) == sum(ndrop))

  anti_join(trials, discard, c("subj_id", "interval"))
}

thresh <- clmm_mod$alpha

newthresh <- double(6)
names(newthresh) <- paste(1:6, 2:7, sep = "|")

## fix the endpoints
newthresh[c(1, 6)] <- thresh[c(1, 5)]

newthresh[2] <- newthresh[1] + (thresh[2] - thresh[1]) * .8
newthresh[3] <- newthresh[2] + (thresh[3] - thresh[2]) * .8

newthresh[5] <- newthresh[6] - (thresh[5] - thresh[4]) * .8
newthresh[4] <- newthresh[5] - (thresh[4] - thresh[3]) * .8

## parse command-line arguments
if (interactive()) {
  nmc <- 5L
  ns <- 88L
  effsize <- .14
} else {
  if (length(commandArgs(TRUE)) < 3L) {
    stop("script must be called with arguments: nsubj effsize nruns")
  }
  ns <- as.integer(commandArgs(TRUE)[1])
  effsize <- as.numeric(commandArgs(TRUE)[2])
  nmc <- as.integer(commandArgs(TRUE)[3])  
}
host <- Sys.info()[["nodename"]]
pid <- Sys.getpid()

slists <- readRDS("stim_lists.rds")

message("Running simulations with ", type, "...")

stime <- system.time(results <- replicate(nmc, {
  dat <- gen_data(ns, newthresh, effsize,
		  VarCorr(clmm_mod)$subj_id,
		  VarCorr(clmm_mod)$item_id,
		  slists)
  do.call(paste0("fit_", type), list(dat))
}))

## don't save if we're just testing
if (!interactive()) {
  dir.create("power_sim_results", FALSE)
  fname <- sprintf("power_sim_results/%s_%04d_0128_%05d_%0.2f_%s_%d.rds",
		   type, ns, nmc, abs(effsize),
		   host, pid)
  saveRDS(results, fname)
}
message("Results saved to ", fname)

power <- sum(results["p_RI", ] < .05) / nmc

message(nmc, " ", type, " simulations completed in ", round(stime[[3]]), " seconds")
message("power for raw effect of ", effsize,
	": ", power)
